<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Log;
use RecursiveDirectoryIterator;
use RecursiveIteratorIterator;

class JsonProcessorController extends Controller
{
    public function processJsonSOS(Request $request)
    {
        try {
            // Configurar lÃ­mites de PHP programÃ¡ticamente
            @ini_set('max_file_uploads', '200');
            @ini_set('upload_max_filesize', '100M');
            @ini_set('post_max_size', '500M');
            @ini_set('max_execution_time', '600');
            @ini_set('memory_limit', '512M');
            
            Log::info('Starting processJsonSOS - Exact Python Script Implementation');
            
            // 1. Validar que se recibieron archivos
            if (!$request->hasFile('files')) {
                return response()->json([
                    'success' => false,
                    'error' => 'No se recibieron archivos'
                ]);
            }

            // 2. Crear directorios temporales (equivalente a rutas Python)
            $srcBasePath = storage_path('app/temp_upload');  // Equivalente a src_directory
            $destBasePath = storage_path('app/json_organizados');  // Equivalente a dest_directory
            
            // Limpiar y crear directorios
            if (File::exists($srcBasePath)) {
                File::deleteDirectory($srcBasePath);
            }
            if (File::exists($destBasePath)) {
                File::deleteDirectory($destBasePath);
            }
            
            File::makeDirectory($srcBasePath, 0755, true);
            
            $results = [
                'success' => true,
                'copied_folders' => 0,
                'renamed_files' => 0,
                'processed_cuv_files' => 0,
                'errors' => []
            ];
            
            // 3. Guardar archivos subidos manteniendo estructura original
            $this->saveUploadedFiles($request->file('files'), $request->input('file_paths', '{}'), $srcBasePath);
            
            // 4. EJECUTAR EXACTAMENTE EL SCRIPT PYTHON
            // FunciÃ³n 1: rename_and_copy_folders(src_base_path, dest_base_path)
            $this->renameAndCopyFoldersExact($srcBasePath, $destBasePath, $results);
            
            // FunciÃ³n 2: process_json_files(dest_base_path)
            $this->processJsonFilesExact($destBasePath, $results);
            
            // 5. Crear paquete de descarga
            $downloadPath = $this->createDownloadPackage($destBasePath);
            $results['download_url'] = '/api/download-processed/' . basename($downloadPath);
            
            Log::info('Process completed successfully', $results);
            
            return response()->json($results);
            
        } catch (\Exception $e) {
            Log::error('Error in processJsonSOS: ' . $e->getMessage());
            Log::error('Stack trace: ' . $e->getTraceAsString());
            
            return response()->json([
                'success' => false,
                'error' => $e->getMessage(),
                'debug_info' => [
                    'line' => $e->getLine(),
                    'file' => basename($e->getFile()),
                    'type' => get_class($e)
                ]
            ]);
        }
    }
    
    public function downloadProcessed($filename)
    {
        try {
            $filename = basename($filename);
            $filePath = storage_path('app/downloads/' . $filename);
            
            Log::info('Download request', [
                'filename' => $filename,
                'path' => $filePath,
                'exists' => File::exists($filePath),
                'is_dir' => is_dir($filePath)
            ]);
            
            if (!File::exists($filePath)) {
                Log::error('File not found', ['path' => $filePath]);
                abort(404, 'Archivo no encontrado');
            }
            
            if (is_dir($filePath)) {
                // Crear TAR como fallback sin ZipArchive
                $tarPath = sys_get_temp_dir() . '/' . $filename . '.tar';
                
                try {
                    $phar = new \PharData($tarPath);
                    $phar->buildFromDirectory($filePath);
                    
                    $filePath = $tarPath;
                    $filename = $filename . '.tar';
                    
                    Log::info('TAR created', [
                        'tar_path' => $tarPath,
                        'size' => filesize($tarPath)
                    ]);
                } catch (\Exception $e) {
                    Log::error('Failed to create TAR', ['error' => $e->getMessage()]);
                    
                    // Ãšltimo fallback: servir el primer archivo como ejemplo
                    $files = File::allFiles($filePath);
                    if (count($files) > 0) {
                        $firstFile = $files[0];
                        $filePath = $firstFile->getPathname();
                        $filename = $firstFile->getFilename();
                        
                        Log::info('Serving first file as fallback', [
                            'file' => $filename,
                            'path' => $filePath
                        ]);
                    } else {
                        abort(500, 'No hay archivos para descargar');
                    }
                }
            }
            
            Log::info('Serving file for download', ['filename' => $filename, 'size' => filesize($filePath)]);
            
            $contentType = 'application/octet-stream';
            if (str_ends_with($filename, '.tar')) {
                $contentType = 'application/x-tar';
            } elseif (str_ends_with($filename, '.zip')) {
                $contentType = 'application/zip';
            }
            
            return response()->download($filePath, $filename, [
                'Content-Type' => $contentType,
                'Content-Disposition' => 'attachment; filename="' . $filename . '"'
            ])->deleteFileAfterSend(isset($tarPath));
            
        } catch (\Exception $e) {
            Log::error('Download error', ['error' => $e->getMessage(), 'filename' => $filename]);
            abort(500, 'Error al descargar el archivo');
        }
    }
    
    /**
     * Guardar archivos subidos manteniendo estructura original
     * Equivalente a preparar src_directory en Python
     */
    private function saveUploadedFiles($files, $filePathsJson, $srcBasePath)
    {
        $filePaths = json_decode($filePathsJson, true) ?? [];
        
        foreach ($files as $index => $file) {
            $originalName = $file->getClientOriginalName();
            $relativePath = $filePaths[$originalName] ?? $originalName;
            $fullPath = $srcBasePath . '/' . $relativePath;
            
            // Crear directorio si no existe
            $directory = dirname($fullPath);
            if (!File::exists($directory)) {
                File::makeDirectory($directory, 0755, true);
            }
            
            // Mover archivo manteniendo nombre original EXACTO
            $file->move($directory, basename($fullPath));
        }
        
        Log::info('Files saved with original structure', [
            'total_files' => count($files),
            'base_path' => $srcBasePath
        ]);
    }
    
    /**
     * IMPLEMENTACIÃ“N EXACTA de rename_and_copy_folders() del script Python
     * 
     * def rename_and_copy_folders(src_base_path, dest_base_path):
     *     os.makedirs(dest_base_path, exist_ok=True)
     *     for root, dirs, files in os.walk(src_base_path):
     *         for folder in dirs:
     *             src_folder_path = os.path.join(root, folder)
     *             relative_path = os.path.relpath(src_folder_path, src_base_path)
     *             new_dest_folder_path = os.path.join(dest_base_path, relative_path)
     *             shutil.copytree(src_folder_path, new_dest_folder_path, dirs_exist_ok=True)
     *             
     *             for filename in os.listdir(new_dest_folder_path):
     *                 if filename.startswith("ResultadosMSPS_"):
     *                     new_filename = f"{folder}-CUV{os.path.splitext(filename)[1]}"
     *                     os.rename(old_file_path, new_file_path)
     */
    private function renameAndCopyFoldersExact($srcBasePath, $destBasePath, &$results)
    {
        // 1. os.makedirs(dest_base_path, exist_ok=True)
        File::makeDirectory($destBasePath, 0755, true);
        
        Log::info('Starting rename_and_copy_folders', [
            'src' => $srcBasePath,
            'dest' => $destBasePath
        ]);
        
        // 2. for root, dirs, files in os.walk(src_base_path):
        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($srcBasePath, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::SELF_FIRST
        );
        
        foreach ($iterator as $item) {
            if ($item->isDir()) {
                // 3. for folder in dirs:
                $srcFolderPath = $item->getPathname();
                $relativePath = str_replace($srcBasePath . DIRECTORY_SEPARATOR, '', $srcFolderPath);
                $newDestFolderPath = $destBasePath . DIRECTORY_SEPARATOR . $relativePath;
                
                // 4. shutil.copytree(src_folder_path, new_dest_folder_path, dirs_exist_ok=True)
                if (!File::exists($newDestFolderPath)) {
                    File::copyDirectory($srcFolderPath, $newDestFolderPath);
                    $results['copied_folders']++;
                    
                    Log::info('âœ… Carpeta copiada', [
                        'src' => $srcFolderPath,
                        'dest' => $newDestFolderPath
                    ]);
                }
                
                // 5. for filename in os.listdir(new_dest_folder_path):
                $folderName = basename($srcFolderPath);
                $filesInFolder = File::files($newDestFolderPath);
                
                foreach ($filesInFolder as $file) {
                    $filename = $file->getFilename();
                    $oldFilePath = $file->getPathname();
                    
                    // 6. if filename.startswith("ResultadosMSPS_"):
                    if (str_starts_with($filename, 'ResultadosMSPS_')) {
                        // 7. new_filename = f"{folder}-CUV{os.path.splitext(filename)[1]}"
                        $extension = pathinfo($filename, PATHINFO_EXTENSION);
                        $newFilename = $folderName . '-CUV.' . $extension;
                        $newFilePath = dirname($oldFilePath) . DIRECTORY_SEPARATOR . $newFilename;
                        
                        // 8. os.rename(old_file_path, new_file_path)
                        if (File::move($oldFilePath, $newFilePath)) {
                            $results['renamed_files']++;
                            
                            Log::info('âœ… Archivo renombrado', [
                                'old' => $filename,
                                'new' => $newFilename
                            ]);
                        }
                    }
                }
            }
        }
        
        Log::info('ðŸ”¹ Proceso de copiado y renombrado finalizado', [
            'copied_folders' => $results['copied_folders'],
            'renamed_files' => $results['renamed_files']
        ]);
    }
    
    /**
     * IMPLEMENTACIÃ“N EXACTA de process_json_files() del script Python
     * 
     * def process_json_files(dest_base_path):
     *     cuv_json_files = glob.glob(os.path.join(dest_base_path, "**", "*CUV.json"), recursive=True)
     *     for archivo_json in cuv_json_files:
     *         nombre_carpeta = os.path.basename(os.path.dirname(archivo_json))
     *         data["RutaArchivos"] = f"C:\\Users\\{nombre_carpeta}"
     *         data.setdefault("ResultadosValidacion", [])
     *         data.setdefault("tipoNota", None)
     *         data.setdefault("numNota", None)
     */
    private function processJsonFilesExact($destBasePath, &$results)
    {
        // 1. cuv_json_files = glob.glob(os.path.join(dest_base_path, "**", "*CUV.json"), recursive=True)
        $cuvJsonFiles = [];
        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($destBasePath, RecursiveDirectoryIterator::SKIP_DOTS)
        );
        
        foreach ($iterator as $file) {
            if ($file->isFile() && str_ends_with($file->getFilename(), 'CUV.json')) {
                $cuvJsonFiles[] = $file->getPathname();
            }
        }
        
        Log::info('Found CUV JSON files', ['count' => count($cuvJsonFiles)]);
        
        $totalCuvCorrectos = 0;
        
        // 2. for archivo_json in cuv_json_files:
        foreach ($cuvJsonFiles as $archivoJson) {
            try {
                // 3. nombre_carpeta = os.path.basename(os.path.dirname(archivo_json))
                $nombreCarpeta = basename(dirname($archivoJson));
                
                // 4. Leer archivo JSON
                $jsonContent = File::get($archivoJson);
                $data = json_decode($jsonContent, true);
                
                if ($data === null) {
                    $results['errors'][] = "âŒ Error al procesar {$archivoJson}: JSON invÃ¡lido";
                    continue;
                }
                
                // 5. data["RutaArchivos"] = f"C:\\Users\\{nombre_carpeta}"
                $data['RutaArchivos'] = "C:\\Users\\{$nombreCarpeta}";
                
                // 6. data.setdefault("ResultadosValidacion", [])
                if (!array_key_exists('ResultadosValidacion', $data)) {
                    $data['ResultadosValidacion'] = [];
                }
                
                // 7. data.setdefault("tipoNota", None)
                if (!array_key_exists('tipoNota', $data)) {
                    $data['tipoNota'] = null;
                }
                
                // 8. data.setdefault("numNota", None)
                if (!array_key_exists('numNota', $data)) {
                    $data['numNota'] = null;
                }
                
                // 9. Escribir archivo JSON modificado
                $jsonOutput = json_encode($data, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);
                File::put($archivoJson, $jsonOutput);
                
                Log::info('âœ… Archivo CUV actualizado correctamente', ['file' => $archivoJson]);
                $totalCuvCorrectos++;
                
            } catch (\Exception $e) {
                $results['errors'][] = "âŒ Error al procesar {$archivoJson}: " . $e->getMessage();
                Log::error('Error processing CUV file', [
                    'file' => $archivoJson,
                    'error' => $e->getMessage()
                ]);
            }
        }
        
        $results['processed_cuv_files'] = $totalCuvCorrectos;
        
        Log::info('ðŸ“Š Resumen del proceso', [
            'total_cuv_correctos' => $totalCuvCorrectos
        ]);
        Log::info('âœ”ï¸ NÃºmero total de CUV modificados correctamente: ' . $totalCuvCorrectos);
    }
    
    /**
     * Crear paquete de descarga desde directorio procesado
     */
    private function createDownloadPackage($sourcePath)
    {
        $downloadsPath = storage_path('app/downloads');
        if (!File::exists($downloadsPath)) {
            File::makeDirectory($downloadsPath, 0755, true);
        }
        
        $packageName = 'json_procesados_sos_' . date('Y-m-d_H-i-s');
        $packagePath = $downloadsPath . '/' . $packageName;
        
        // Copiar directorio completo procesado
        if (File::exists($packagePath)) {
            File::deleteDirectory($packagePath);
        }
        
        File::copyDirectory($sourcePath, $packagePath);
        
        Log::info('Download package created', [
            'source' => $sourcePath,
            'package' => $packagePath,
            'files_count' => count(File::allFiles($packagePath))
        ]);
        
        return $packagePath;
    }
    
    }